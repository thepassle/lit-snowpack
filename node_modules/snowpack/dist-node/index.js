'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var fs = _interopDefault(require('fs'));
var path = _interopDefault(require('path'));
var rimraf = _interopDefault(require('rimraf'));
var mkdirp = _interopDefault(require('mkdirp'));
var chalk = _interopDefault(require('chalk'));
var ora = _interopDefault(require('ora'));
var yargs = _interopDefault(require('yargs-parser'));
var resolveFrom = _interopDefault(require('resolve-from'));
var babelPresetEnv = _interopDefault(require('@babel/preset-env'));
var isNodeBuiltin = _interopDefault(require('is-builtin-module'));
var rollup = require('rollup');
var rollupPluginNodeResolve = _interopDefault(require('rollup-plugin-node-resolve'));
var rollupPluginCommonjs = _interopDefault(require('rollup-plugin-commonjs'));
var rollupPluginTerser = require('rollup-plugin-terser');
var rollupPluginReplace = _interopDefault(require('rollup-plugin-replace'));
var rollupPluginJson = _interopDefault(require('rollup-plugin-json'));
var rollupPluginBabel = _interopDefault(require('rollup-plugin-babel'));
var glob = _interopDefault(require('glob'));
var parser = require('@babel/parser');
var traverse = _interopDefault(require('@babel/traverse'));

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

/**
 * rollup-plugin-treeshake-inputs
 *
 * How it works:
 * 1. An array of "install targets" are passed in, describing all known imports + metadata.
 * 2. Known imports are marked for tree-shaking by appending 'pika-treeshake:' to the input value.
 * 3. On load, we return a false virtual file for all "pika-treeshake:" inputs.
 *    a. That virtual file contains only `export ... from 'ACTUAL_FILE_PATH';` exports
 *    b. Rollup uses those exports to drive its tree-shaking algorithm.
 */
function rollupPluginTreeshakeInputs(allImports) {
  const installTargetsByFile = {};
  return {
    name: 'pika:treeshake-inputs',

    // Mark some inputs for tree-shaking.
    options(inputOptions) {
      for (const [key, val] of Object.entries(inputOptions.input)) {
        installTargetsByFile[val] = allImports.filter(imp => imp.specifier === key); // If an input has known install targets, and none of those have "all=true", mark for treeshaking.

        if (installTargetsByFile[val].length > 0 && !installTargetsByFile[val].some(imp => imp.all)) {
          inputOptions.input[key] = `pika-treeshake:${val}`;
        }
      }

      return inputOptions;
    },

    resolveId(source) {
      if (source.startsWith('pika-treeshake:')) {
        return source;
      }

      return null;
    },

    load(id) {
      if (!id.startsWith('pika-treeshake:')) {
        return null;
      }

      const fileLoc = id.substring('pika-treeshake:'.length); // Reduce all install targets into a single "summarized" install target.

      const treeshakeSummary = installTargetsByFile[fileLoc].reduce((summary, imp) => {
        summary.default = summary.default || imp.default;
        summary.namespace = summary.namespace || imp.namespace;
        summary.named = [...summary.named, ...imp.named];
        return summary;
      });
      const uniqueNamedImports = new Set(treeshakeSummary.named);
      const result = `
        ${treeshakeSummary.namespace ? `export * from '${fileLoc}';` : ''}
        ${treeshakeSummary.default ? `import __pika_web_default_export_for_treeshaking__ from '${fileLoc}'; export default __pika_web_default_export_for_treeshaking__;` : ''}
        ${`export {${[...uniqueNamedImports].join(',')}} from '${fileLoc}';`}
      `;
      return result;
    }

  };
}

/**
 * rollup-plugin-remote-resolve
 *
 * Rewrites imports for "remote packages" to point to the remote URL instead.
 * This shouldn't ever run by default, but must be activated via config.
 */
function rollupPluginRemoteResolve({
  remoteUrl,
  remotePackages
}) {
  const remotePackageMap = new Map(remotePackages);
  return {
    name: 'pika:peer-dependency-resolver',

    resolveId(source) {
      if (remotePackageMap.has(source)) {
        let urlSourcePath = source; // NOTE(@fks): This is really Pika CDN specific, but no one else should be using this option.

        if (source === 'react' || source === 'react-dom') {
          urlSourcePath = '_/' + source;
        }

        return {
          id: `${remoteUrl}/${urlSourcePath}/${remotePackageMap.get(source)}`,
          external: true,
          isExternal: true
        };
      }

      return null;
    },

    load(id) {
      return null;
    }

  };
}

function stripJsExtension(dep) {
  return dep.replace(/\.m?js$/i, '');
}

function createInstallTarget(specifier, all = true) {
  return {
    specifier,
    all,
    default: false,
    namespace: false,
    named: []
  };
}
/**
 * parses an import specifier, looking for a web modules to install. If a web module is not detected,
 * null is returned.
 */


function parseWebModuleSpecifier(specifier, knownDependencies) {
  const webModulesIndex = specifier.indexOf('web_modules/');

  if (webModulesIndex === -1) {
    return null;
  } // check if the resolved specifier (including file extension) is a known package.


  const resolvedSpecifier = specifier.substring(webModulesIndex + 'web_modules/'.length);

  if (knownDependencies.includes(resolvedSpecifier)) {
    return resolvedSpecifier;
  } // check if the resolved specifier (without extension) is a known package.


  const resolvedSpecifierWithoutExtension = stripJsExtension(resolvedSpecifier);

  if (knownDependencies.includes(resolvedSpecifierWithoutExtension)) {
    return resolvedSpecifierWithoutExtension;
  } // Otherwise, this is an explicit import to a file within a package.


  return resolvedSpecifier;
}

function getInstallTargetsForFile(filePath, code, knownDependencies) {
  const allImports = [];

  try {
    const ast = parser.parse(code, {
      plugins: ['dynamicImport'],
      sourceType: 'module'
    });
    traverse(ast, {
      ImportDeclaration(path) {
        const webModuleSpecifier = parseWebModuleSpecifier(path.node.source.value, knownDependencies);

        if (webModuleSpecifier) {
          allImports.push({
            specifier: webModuleSpecifier,
            all: false,
            default: path.node.specifiers.some(s => s.type === 'ImportDefaultSpecifier'),
            namespace: path.node.specifiers.some(s => s.type === 'ImportNamespaceSpecifier'),
            named: path.node.specifiers.map(s => s.type === 'ImportSpecifier' && s.imported.name).filter(Boolean)
          });
        }
      },

      Import(path) {
        // Only match dynamic imports that are called as a function
        if (path.parent.type !== 'CallExpression') {
          return;
        } // Only match dynamic imports called with a single string argument


        const [argNode] = path.parent.arguments;

        if (argNode.type !== 'StringLiteral') {
          return;
        } // Analyze that string argument as an import specifier


        const webModuleSpecifier = parseWebModuleSpecifier(argNode.value, knownDependencies);

        if (webModuleSpecifier) {
          allImports.push(createInstallTarget(webModuleSpecifier, true));
        }
      }

    });
  } catch (e) {
    console.error(`[PARSE ERROR]: Skipping ${filePath}`);
    return [];
  }

  return allImports;
}

function scanDepList(depList, cwd) {
  const nodeModulesLoc = path.join(cwd, 'node_modules');
  return depList.map(whitelistItem => {
    if (!glob.hasMagic(whitelistItem)) {
      return [createInstallTarget(whitelistItem, true)];
    } else {
      return scanDepList(glob.sync(whitelistItem, {
        cwd: nodeModulesLoc,
        nodir: true
      }), cwd);
    }
  }).reduce((flat, item) => flat.concat(item), []);
}
function scanImports({
  include,
  exclude,
  knownDependencies
}) {
  const includeFiles = glob.sync(include, {
    ignore: exclude,
    nodir: true
  });

  if (!includeFiles.length) {
    console.warn(`[SCAN ERROR]: No files matching "${include}"`);
    return [];
  } // Scan every matched JS file for web dependency imports


  return includeFiles.filter(filePath => filePath.endsWith('.js') || filePath.endsWith('mjs')).map(filePath => [filePath, fs.readFileSync(filePath, 'utf8')]).map(([filePath, code]) => getInstallTargetsForFile(filePath, code, knownDependencies)).reduce((flat, item) => flat.concat(item), []).sort((impA, impB) => impA.specifier.localeCompare(impB.specifier));
}

const cwd = process.cwd();
const banner = chalk.bold(`snowpack`) + ` installing... `;
const installResults = [];
let spinner = ora(banner);
let spinnerHasError = false;

function printHelp() {
  console.log(`
${chalk.bold(`snowpack`)} - Install npm dependencies to run natively on the web.
${chalk.bold('Options:')}
    --dest              Specify destination directory (default: "web_modules/").
    --clean             Clear out the destination directory before install.
    --optimize          Transpile, minify, and optimize installed dependencies for production.
    --babel             Transpile installed dependencies. Also enabled with "--optimize".
    --include           Auto-detect imports from file(s). Supports glob.
    --exclude           Exclude files from --include. Follows glob’s ignore pattern.
    --strict            Only install pure ESM dependency trees. Fail if a CJS module is encountered.
    --no-source-map     Skip emitting source map files (.js.map) into dest
${chalk.bold('Advanced:')}
    --remote-package    "name,version" pair(s) of packages that should be left unbundled and referenced remotely.
                        Example: "foo,v4" will rewrite all imports of "foo" to "{remoteUrl}/foo/v4" (see --remote-url).
    --remote-url        Configures the domain where remote imports point to (default: "https://cdn.pika.dev")
    `.trim());
}

function formatInstallResults(skipFailures) {
  return installResults.map(([d, yn]) => yn ? chalk.green(d) : skipFailures ? chalk.dim(d) : chalk.red(d)).join(', ');
}

function logError(msg) {
  if (!spinnerHasError) {
    spinner.stopAndPersist({
      symbol: chalk.cyan('⠼')
    });
  }

  spinnerHasError = true;
  spinner = ora(chalk.red(msg));
  spinner.fail();
}

class ErrorWithHint extends Error {
  constructor(message, hint) {
    super(message);
    this.hint = hint;
  }

} // Add common, well-used non-esm packages here so that Rollup doesn't die trying to analyze them.


const PACKAGES_TO_AUTO_DETECT_EXPORTS = [path.join('react', 'index.js'), path.join('react-dom', 'index.js'), path.join('react-is', 'index.js'), path.join('prop-types', 'index.js'), path.join('rxjs', 'Rx.js')];

function detectExports(filePath) {
  try {
    const fileLoc = resolveFrom(cwd, filePath);

    if (fs.existsSync(fileLoc)) {
      return Object.keys(require(fileLoc)).filter(e => e[0] !== '_');
    }
  } catch (err) {// ignore
  }
}
/**
 * Resolve a "webDependencies" input value to the correct absolute file location.
 * Supports both npm package names, and file paths relative to the node_modules directory.
 * Follows logic similar to Node's resolution logic, but using a package.json's ESM "module"
 * field instead of the CJS "main" field.
 */


function resolveWebDependency(dep, isExplicit) {
  // if the path includes a file extension, just use it
  if (path.extname(dep)) {
    const isJSFile = ['.js', '.mjs', '.cjs'].includes(path.extname(dep));
    return {
      type: isJSFile ? 'JS' : 'ASSET',
      loc: resolveFrom(cwd, dep)
    };
  }

  const depManifestLoc = resolveFrom(cwd, `${dep}/package.json`);

  const depManifest = require(depManifestLoc);

  let foundEntrypoint = depManifest['browser:module'] || depManifest.module || depManifest.browser; // If the package was a part of the explicit whitelist, fallback to it's main CJS entrypoint.

  if (!foundEntrypoint && isExplicit) {
    foundEntrypoint = depManifest.main || 'index.js';
  }

  if (!foundEntrypoint) {
    throw new ErrorWithHint(`dependency "${dep}" has no native "module" entrypoint.`, chalk.italic(`Tip: Find modern, web-ready packages at ${chalk.underline('https://www.pika.dev')}`));
  }

  if (dep === 'react' && foundEntrypoint === 'index.js') {
    throw new ErrorWithHint(`dependency "react" has no native "module" entrypoint.`, chalk.italic(`See: ${chalk.underline('https://github.com/pikapkg/web#a-note-on-react')}`));
  }

  return {
    type: 'JS',
    loc: path.join(depManifestLoc, '..', foundEntrypoint)
  };
}
/**
 * Formats the snowpack dependency name from a "webDependencies" input value:
 * 2. Remove any ".js"/".mjs" extension (will be added automatically by Rollup)
 */


function getWebDependencyName(dep) {
  return dep.replace(/\.m?js$/i, '');
}

async function install(installTargets, {
  isCleanInstall,
  destLoc,
  hasBrowserlistConfig,
  isExplicit,
  isStrict,
  isBabel,
  isOptimized,
  sourceMap,
  namedExports,
  remoteUrl,
  remotePackages,
  dedupe
}) {
  const knownNamedExports = _objectSpread2({}, namedExports);

  for (const filePath of PACKAGES_TO_AUTO_DETECT_EXPORTS) {
    knownNamedExports[filePath] = knownNamedExports[filePath] || detectExports(filePath) || [];
  }

  if (installTargets.length === 0) {
    logError('Nothing to install.');
    return;
  }

  if (!fs.existsSync(path.join(cwd, 'node_modules'))) {
    logError('no "node_modules" directory exists. Did you run "npm install" first?');
    return;
  }

  if (isCleanInstall) {
    rimraf.sync(destLoc);
  }

  const allInstallSpecifiers = new Set(installTargets.map(dep => dep.specifier));
  const depObject = {};
  const assetObject = {};
  const importMap = {};
  const installTargetsMap = {};
  const skipFailures = !isExplicit;

  for (const installSpecifier of allInstallSpecifiers) {
    try {
      const targetName = getWebDependencyName(installSpecifier);
      const {
        type: targetType,
        loc: targetLoc
      } = resolveWebDependency(installSpecifier, isExplicit);

      if (targetType === 'JS') {
        depObject[targetName] = targetLoc;
        importMap[targetName] = `./${targetName}.js`;
        installTargetsMap[targetLoc] = installTargets.filter(t => installSpecifier === t.specifier);
        installResults.push([installSpecifier, true]);
      } else if (targetType === 'ASSET') {
        assetObject[targetName] = targetLoc;
        installResults.push([installSpecifier, true]);
      }

      spinner.text = banner + formatInstallResults(skipFailures);
    } catch (err) {
      installResults.push([installSpecifier, false]);
      spinner.text = banner + formatInstallResults(skipFailures);

      if (skipFailures) {
        continue;
      } // An error occurred! Log it.


      logError(err.message || err);

      if (err.hint) {
        console.log(err.hint);
      }

      return false;
    }
  }

  if (Object.keys(depObject).length === 0 && Object.keys(assetObject).length === 0) {
    logError(`No ESM dependencies found!`);
    console.log(chalk.dim(`  At least one dependency must have an ESM "module" entrypoint. You can find modern, web-ready packages at ${chalk.underline('https://www.pika.dev')}`));
    return false;
  }

  if (Object.keys(depObject).length > 0) {
    const inputOptions = {
      input: depObject,
      plugins: [!isStrict && rollupPluginReplace({
        'process.env.NODE_ENV': isOptimized ? '"production"' : '"development"'
      }), remoteUrl && rollupPluginRemoteResolve({
        remoteUrl,
        remotePackages
      }), rollupPluginNodeResolve({
        mainFields: ['browser:module', 'module', 'browser', !isStrict && 'main'].filter(Boolean),
        modulesOnly: isStrict,
        extensions: ['.mjs', '.cjs', '.js', '.json'],
        // whether to prefer built-in modules (e.g. `fs`, `path`) or local ones with the same names
        preferBuiltins: false,
        dedupe: dedupe
      }), !isStrict && rollupPluginJson({
        preferConst: true,
        indent: '  '
      }), !isStrict && rollupPluginCommonjs({
        extensions: ['.js', '.cjs'],
        namedExports: knownNamedExports
      }), !!isBabel && rollupPluginBabel({
        compact: false,
        babelrc: false,
        presets: [[babelPresetEnv, {
          modules: false,
          targets: hasBrowserlistConfig ? undefined : '>0.75%, not ie 11, not UCAndroid >0, not OperaMini all'
        }]]
      }), !!isOptimized && rollupPluginTreeshakeInputs(installTargets), !!isOptimized && rollupPluginTerser.terser()],
      onwarn: (warning, warn) => {
        if (warning.code === 'UNRESOLVED_IMPORT') {
          // If we're using remoteUrl, we should expect them to be unresolved. ("external" should handle this for us, but we're still seeing it)
          if (remoteUrl && warning.source.startsWith(remoteUrl)) {
            return;
          }

          logError(`'${warning.source}' is imported by '${warning.importer}', but could not be resolved.`);

          if (isNodeBuiltin(warning.source)) {
            console.log(chalk.dim(`  '${warning.source}' is a Node.js builtin module that won't exist on the web. You can find modern, web-ready packages at ${chalk.underline('https://www.pika.dev')}`));
          } else {
            console.log(chalk.dim(`  Make sure that the package is installed and that the file exists.`));
          }

          return;
        }

        warn(warning);
      }
    };
    const outputOptions = {
      dir: destLoc,
      format: 'esm',
      sourcemap: sourceMap === undefined ? isOptimized : sourceMap,
      exports: 'named',
      chunkFileNames: 'common/[name]-[hash].js'
    };
    const packageBundle = await rollup.rollup(inputOptions);
    await packageBundle.write(outputOptions);
    fs.writeFileSync(path.join(destLoc, 'import-map.json'), JSON.stringify({
      imports: importMap
    }, undefined, 2), {
      encoding: 'utf8'
    });
  }

  Object.entries(assetObject).forEach(([assetName, assetLoc]) => {
    mkdirp.sync(path.dirname(`${destLoc}/${assetName}`));
    fs.copyFileSync(assetLoc, `${destLoc}/${assetName}`);
  });
  return true;
}
async function cli(args) {
  const {
    help,
    sourceMap,
    babel = false,
    exclude = ['**/__tests__/*', '**/*.@(spec|test).@(js|mjs)'],
    optimize = false,
    include,
    strict = false,
    clean = false,
    dest = 'web_modules',
    remoteUrl = 'https://cdn.pika.dev',
    remotePackage: remotePackages = []
  } = yargs(args);
  const destLoc = path.resolve(cwd, dest);

  if (help) {
    printHelp();
    process.exit(0);
  }

  const pkgManifest = require(path.join(cwd, 'package.json'));

  const implicitDependencies = [...Object.keys(pkgManifest.dependencies || {}), ...Object.keys(pkgManifest.peerDependencies || {})];
  const allDependencies = [...Object.keys(pkgManifest.dependencies || {}), ...Object.keys(pkgManifest.peerDependencies || {}), ...Object.keys(pkgManifest.devDependencies || {})];
  let isExplicit = false;
  const installTargets = [];
  const {
    namedExports,
    webDependencies,
    dedupe
  } = pkgManifest['snowpack'] || {
    namedExports: undefined,
    webDependencies: undefined,
    dedupe: undefined
  };

  if (pkgManifest['@pika/web']) {
    console.log('[WARN] Update package.json "@pika/web" configuration to use "snowpack" configuration name.');
  }

  if (webDependencies) {
    isExplicit = true;
    installTargets.push(...scanDepList(webDependencies, cwd));
  }

  if (include) {
    isExplicit = true;
    installTargets.push(...scanImports({
      include,
      exclude,
      knownDependencies: allDependencies
    }));
  }

  if (!webDependencies && !include) {
    installTargets.push(...scanDepList(implicitDependencies, cwd));
  }

  const hasBrowserlistConfig = !!pkgManifest.browserslist || !!process.env.BROWSERSLIST || fs.existsSync(path.join(cwd, '.browserslistrc')) || fs.existsSync(path.join(cwd, 'browserslist'));
  spinner.start();
  const startTime = Date.now();
  const result = await install(installTargets, {
    isCleanInstall: clean,
    destLoc,
    namedExports,
    isExplicit,
    isStrict: strict,
    isBabel: babel || optimize,
    isOptimized: optimize,
    sourceMap,
    remoteUrl,
    hasBrowserlistConfig,
    remotePackages: remotePackages.map(p => p.split(',')),
    dedupe
  });

  if (result) {
    spinner.succeed(chalk.bold(`snowpack`) + ` installed: ` + formatInstallResults(!isExplicit) + '.' + chalk.dim(` [${((Date.now() - startTime) / 1000).toFixed(2)}s]`));
  } //If an error happened, set the exit code so that programmatic usage of the CLI knows.


  if (spinnerHasError) {
    spinner.warn(chalk(`Finished with warnings.`));
    process.exitCode = 1;
  }
}

exports.cli = cli;
exports.install = install;
//# sourceMappingURL=index.js.map
